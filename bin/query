#!/usr/bin/env node

var clientLocation = (process.env.CLIENTDIR || '') + 'ldf-client';

var fs = require('fs'),
  SparqlParser = require('sparqljs').Parser,
  ldf = require(clientLocation),
  util = require('../lib/RdfUtils.js'),
  Composer = require('../lib/SparqlComposer.js');
require('js-object-clone');

var tempqueryfile = "./radio.sparql",
    query = fs.readFileSync(tempqueryfile).toString();

var SparqlParser = require('sparqljs').Parser;

var debugMode = false;

// Allowed types: reification, singletonproperties, graphs
var type = process.argv.length > 2 ? process.argv[2] : "reification";

ldf.Logger.setLevel('error');

var parser = new SparqlParser();
debug(function() {
    console.log("------\nOriginal query:\n------");
    console.log(query);
    console.log("------");
});
var query = parser.parse(query);
//console.log(JSON.stringify(query, null, "  "));

var fragmentsClient = new ldf.FragmentsClient('http://localhost:3000/radio'); // TODO

var tripleTransformer = {
    reification: util.timeAnnotatedReification,
    singletonproperties: util.timeAnnotatedSingletonProperties,
    graphs: util.timeAnnotatedQuads,
}[type];

executeTransformation(query.prefixes, query.variables, query.where, function(modifiedQuery, hasTimeAnnotation) {
    query.where = modifiedQuery;

    if(hasTimeAnnotation) {
        query.variables = query.variables.concat(["?initial", "?final"]);
        query.prefixes = extendObject({
            "tmp": util.prefixes.tmp,
            "sp": util.prefixes.sp,
        }, query.prefixes)
    }

    //console.log(JSON.stringify(query, null, "  "));

    // TODO: construct a new query using from JSON format
    var composer = new Composer(query);
    var result = composer.compose();
    debug(function() {
        console.log("------\nNew query:\n------");
        console.log("Has time annotation? " + (hasTimeAnnotation ? "true" : "false") + "\n");
        console.log(result);
        console.log("------");
        console.log("\nLive query results:\n------------------------\n");
    });
    var context = {counter: 0, hasTimeAnnotation: hasTimeAnnotation};
    executeQuery(result, context);
});

function flatten(array) { return [].concat.apply([], array); }

/**
 * Reify a query.
 * This will loop over each triple pattern fragment and modify it to an equivalent reified form
 * if a query to the endpoint pointed out that it has a reified form for that triple.
 * @param prefixes The accumulated prefixes
 * @param variables The accumulated variables
 * @param queryPart The input query part.
 * @param resultsCallback Callback with the resulting modified query part.
 */
function executeTransformation(prefixes, variables, queryPart, resultsCallback) {
    if(queryPart instanceof Array) {
        var result = [];
        var bufferHasTimeAnnotation = false;
        for(var i = 0; i < queryPart.length; i++) {
            executeTransformation(prefixes, variables, queryPart[i], function(modifiedQueryPart, hasTimeAnnotation) {
                result.push(modifiedQueryPart);
                bufferHasTimeAnnotation = hasTimeAnnotation | bufferHasTimeAnnotation;
                if(result.length == queryPart.length) {
                    resultsCallback(flatten(result), bufferHasTimeAnnotation);
                }
            });
        }
    } else if(queryPart.type == "bgp") {
        var result = Object.clone(queryPart);
        executeTransformation(prefixes, variables, queryPart.triples, function(modifiedQueryPart, hasTimeAnnotation) {
            result.triples = modifiedQueryPart;
            resultsCallback(result, hasTimeAnnotation);
        });
    } else if(queryPart.type == "union") {
        var result = Object.clone(queryPart);
        executeTransformation(prefixes, variables, queryPart.patterns, function(modifiedQueryPart, hasTimeAnnotation) {
            result.patterns = modifiedQueryPart;
            resultsCallback(result, hasTimeAnnotation);
        });
    } else {
        shouldTransform(prefixes, variables, queryPart, function(shouldTransform, hasTimeAnnotation) {
            if(shouldTransform) {
                var modified = tripleTransformer(queryPart) || { // TODO: tmp!!!
                    type: "union",
                    patterns: [
                        queryPart,
                        tripleTransformer(queryPart)
                    ]
                };
                resultsCallback(modified, true);
            } else {
                resultsCallback(queryPart, hasTimeAnnotation);
            }
        });
    }
}

function extendObject(self, source) {
    for (var property in source) {
        if (source.hasOwnProperty(property)) {
            self[property] = source[property];
        }
    }
    return self;
};

/**
 * Check if the given triple should be transformed (reified || ...).
 * @param prefixes The accumulated prefixes
 * @param variables The accumulated variables
 * @param triple The triple object.
 * @param callback The true/false callback.
 */
function shouldTransform(prefixes, variables, triple, callback) {
    var query = { // TODO: improve
        "type": "query",
        "prefixes": extendObject({
            "tmp": util.prefixes.tmp,
            "sp": util.prefixes.sp
        }, prefixes),
        "queryType": "SELECT",
        "variables": variables.concat([
            "?initial",
            "?final"
        ]),
        "where": [
            {
                "type": "bgp",
                "triples": tripleTransformer(triple),
            }
        ]
    };
    var composer = new Composer(query);
    var result = composer.compose();
    debug(function() {
        console.log("Transformation: --- \n" + result + "\n--- \n");
    });
    isQueryNotEmpty(result, function(res) {
        debug(function() {
            console.log("Triple " + JSON.stringify(triple) + " should" + (res ? "" : " NOT") + " be transformed.");
        });
        callback(res);
    });
}

/**
 * Perform a query to the server to check if the given query gives at least one result.
 * @param query The query.
 * @param callback The callback with true (query result is not empty) or false (query result is empty).
 */
function isQueryNotEmpty(query, callback) {
    var results = new ldf.SparqlIterator(query, { fragmentsClient: fragmentsClient });
    var shouldCall = true;
    results.on('data', function (row) {
        //console.log(row);
        shouldCall && !(shouldCall = false && results.end()) && callback(true);
        // Stop the iterator, we already have all the info we need.
    });
    results.on('end', function() {
        shouldCall && !(shouldCall = false) && callback(false);
        shouldCall = false;
    });
    results.on('error', function() {
        shouldCall && callback(false);
        shouldCall = false;
    });
}

function executeQuery(query, context) {
    console.log("Result: " + context.counter++ + "\n------\n");
    fragmentsClient = new ldf.FragmentsClient('http://localhost:3000/radio'); // TODO: bug in FragmentsClient cache?
    var results = new ldf.SparqlIterator(query, { fragmentsClient: fragmentsClient });
    results.on('data', function (row) {
        //console.log(row);
        if(isCurrent(row)) {
            console.log({
                "?track": row["?track"],
                "?tracktitle": row["?tracktitle"]
            });
            context.updateAt = getUpdateTime(row);
        }
    });
    results.on('end', function() {
        if(context.hasTimeAnnotation && context.updateAt) {
            var timeOut = context.updateAt - (new Date().getTime());
            if(timeOut < 0) {
                timeOut = 10000;
                console.log("No newer data found on server, will wait 10 seconds.");
            } else {
                console.log("Will update after: " + timeOut/1000 + "s");
            }
            setTimeout(function() {
                executeQuery(query, context);
            }, timeOut);
        }
    });
    results.on('error', function(e) {
        console.log("Error while streaming! " + e);
    });
}

function getUpdateTime(variables) {
    return parseTimeVariable(variables["?final"]);
}

function isCurrent(variables) {
    var initial = parseTimeVariable(variables["?initial"]);
    var final = parseTimeVariable(variables["?final"]);
    var current = new Date().getTime();
    return initial <= current && current <= final;
}

function parseTimeVariable(timeVariable) {
    var timeString = timeVariable.replace(/\^\^.*/g, "").replace(/"/g, "");
    return Date.parse(timeString);
}

function debug(callback) {
    debugMode && callback();
}